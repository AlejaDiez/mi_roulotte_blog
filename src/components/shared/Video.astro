---
import type { BaseProps } from "@models/props";

export interface Props extends BaseProps {
    url: string;
    title?: string;
    thumbnail?: string;
}

const getYoutubeId = (url: string) => {
    if (!URL.canParse(url)) return null;

    const urlObject = new URL(url);

    if (urlObject.hostname.includes("youtube.com")) {
        const params = urlObject.pathname.slice(1).split("/");

        if (params.includes("watch")) {
            return urlObject.searchParams.get("v");
        } else if (params.includes("shorts")) {
            return params.at(-1) ?? null;
        } else if (params.includes("playlist")) {
            return urlObject.searchParams.get("list");
        }
    } else if (urlObject.hostname.includes("youtu.be")) {
        return urlObject.pathname.slice(1);
    }
    return null;
};

const { url, id, style, class: cls } = Astro.props;
let { title, thumbnail } = Astro.props;
const youtubeId = getYoutubeId(url);

if (youtubeId && (!title || !thumbnail)) {
    const data = await fetch(
        `https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${youtubeId}&format=json`,
        {
            cf: {
                cacheEverything: true,
                cacheTtl: 86400,
                cacheTtlByStatus: {
                    "200-299": 86400,
                    "404": 60,
                    "500-599": 0
                }
            }
        } as RequestInit
    ).then((res) => res.json<any>());

    title = title ?? data["title"];
    thumbnail = thumbnail ?? data["thumbnail_url"];
}
---

<div
    {id}
    {style}
    class:list={cls}
    class="video bg-muted group relative aspect-video h-auto w-auto cursor-default overflow-hidden select-none"
    aria-label={title ? `Reproductor de video: ${title}` : "Reproductor de video"}>
    <div
        class="preview group/alt absolute top-0 left-0 z-20 h-full w-full data-hidden:pointer-events-none">
        <img
            src={thumbnail}
            alt=""
            loading="lazy"
            decoding="async"
            class="img bg-muted h-full w-full border-none object-cover transition-[scale,opacity] duration-300 outline-none group-data-hidden/alt:scale-110 group-data-hidden/alt:opacity-0"
            aria-hidden="true"
        />
        <span
            class="text-headline caption absolute top-0 left-0 h-24 w-full bg-linear-to-b from-[#00000099] p-6 text-white transition-[translate,opacity] duration-300 group-data-hidden/alt:-translate-y-100 group-data-hidden/alt:opacity-0"
            aria-hidden="true">
            {title}
        </span>
        <button
            class="player-state button button-fill-primary absolute top-1/2 left-1/2 h-20 max-h-none w-20 -translate-1/2 rounded-full p-0 transition-[background-color,scale,opacity] group-data-hidden/alt:opacity-0 hover:scale-110"
            aria-label="Reproducir video"
            tabindex="-1">
            <i
                class="ibm-play-filled-alt group-data-[state=buffering]:hidden group-data-[state=ended]:hidden group-data-[state=playing]:hidden"
                aria-hidden="true">
            </i>
            <i class="ibm-pause-filled group-not-data-[state=playing]:hidden" aria-hidden="true"
            ></i>
            <i class="ibm-rotate-360 group-not-data-[state=ended]:hidden" aria-hidden="true"></i>
            <span
                class="spinner-alt border-current border-b-transparent group-not-data-[state=buffering]:hidden"
                aria-hidden="true">
            </span>
        </button>
    </div>
    <div class="player absolute top-0 left-0 h-full w-full bg-black">
        {
            youtubeId ? (
                <source
                    src={url}
                    type="video/youtube"
                    class="pointer-events-none h-full w-full border-none object-cover outline-none"
                />
            ) : (
                <video
                    src={url}
                    playsinline
                    class="pointer-events-none h-full w-full border-none object-cover outline-none"
                />
            )
        }
    </div>
    <div
        class="controls is-hidden clip-none bg-muted data-hidden:clip-top absolute bottom-0 left-0 z-10 flex h-14 w-full flex-row items-center justify-start transition-[clip-path] duration-300"
        aria-label="Controles del reproductor">
        <button
            class="player-state button button-primary relative h-14 w-14 p-0"
            aria-label="Cambiar estado del video"
            tabindex="-1">
            <i
                class="ibm-play-filled-alt group-data-[state=buffering]:hidden group-data-[state=ended]:hidden group-data-[state=playing]:hidden"
                aria-hidden="true">
            </i>
            <i class="ibm-pause-filled group-not-data-[state=playing]:hidden" aria-hidden="true">
            </i>
            <i class="ibm-rotate-360 group-not-data-[state=ended]:hidden" aria-hidden="true"></i>
            <span class="spinner-alt group-not-data-[state=buffering]:hidden" aria-hidden="true"
            ></span>
        </button>
        <label class="player-time">
            <span class="text-label elapsed-time" aria-live="off">00:00</span>
            <input
                type="range"
                min="0"
                max="1"
                step="0.01"
                class="slider"
                aria-label="Control de progreso del video"
            />
            <span class="text-label remaining-time" aria-live="off">-00:00</span>
        </label>
        <div class="options flex h-14 flex-row items-center justify-start px-2">
            <button
                class="screen group/alt button button-primary group h-10 min-h-0 w-10 min-w-0 p-0"
                aria-label="Pantalla completa"
                tabindex="-1">
                <i class="ibm-maximize group-data-maximized/alt:hidden" aria-hidden="true"></i>
                <i class="ibm-minimize group-not-data-maximized/alt:hidden" aria-hidden="true"></i>
            </button>
        </div>
    </div>

    <script>
        import { formatDuration } from "@utils/datetime";

        class VideoController {
            private nativePlayer: HTMLVideoElement | null;
            private youtubePlayer: YT.Player | HTMLSourceElement | null;
            readonly type: string;
            readonly container: HTMLDivElement;
            onReady?: () => void;
            onUnstarted?: () => void;
            onEnded?: () => void;
            onPlaying?: () => void;
            onPaused?: () => void;
            onBuffering?: () => void;
            onCued?: () => void;
            onSeek?: (currentTime: number, duration: number) => void;

            constructor(video: HTMLDivElement) {
                this.container = video.querySelector<HTMLDivElement>(".player")!;
                this.nativePlayer = this.container.querySelector<HTMLVideoElement>("video");
                this.youtubePlayer = this.container.querySelector<HTMLSourceElement>("source");

                // Get player type
                if (this.nativePlayer) {
                    this.type = "native";
                    // Add listeners
                    this.nativePlayer!.addEventListener("canplay", () => {
                        this.onReady?.();
                    });
                    this.nativePlayer!.addEventListener("playing", () => {
                        this.onPlaying?.();
                    });
                    this.nativePlayer!.addEventListener("pause", () => {
                        if (!this.nativePlayer!.ended) {
                            this.onPaused?.();
                        }
                    });
                    this.nativePlayer!.addEventListener("waiting", () => {
                        this.onBuffering?.();
                    });
                    this.nativePlayer!.addEventListener("ended", () => {
                        this.onEnded?.();
                    });
                    this.nativePlayer!.addEventListener("timeupdate", () => {
                        this.onSeek?.(this.getCurrentTime(), this.getDuration());
                    });
                } else if (this.getYoutubeId(this.youtubePlayer?.src ?? "")) {
                    this.type = "youtube";
                    // Load youtube iframe api
                    if (
                        !document.head.querySelector(
                            'script[src="https://www.youtube.com/iframe_api"]'
                        )
                    ) {
                        const script: HTMLScriptElement = document.createElement("script");

                        script.setAttribute("src", "https://www.youtube.com/iframe_api");
                        document.head.appendChild(script);
                    }
                } else {
                    throw new Error("No video player found");
                }
            }

            private initIframe(onReady?: (player: YT.Player) => void) {
                if (this.youtubePlayer instanceof HTMLSourceElement) {
                    this.youtubePlayer = this.buildYoutubeIframe(this.youtubePlayer!, {
                        onReady: () => {
                            this.onReady?.();
                            onReady?.(this.youtubePlayer as YT.Player);
                        },
                        onUnstarted: this.onUnstarted,
                        onEnded: this.onEnded,
                        onPlaying: this.onPlaying,
                        onPaused: this.onPaused,
                        onBuffering: this.onBuffering,
                        onCued: this.onCued,
                        onSeek: this.onSeek
                    });
                }
            }

            private getYoutubeId(url: string) {
                if (!URL.canParse(url)) {
                    return null;
                }

                const urlObject = new URL(url);

                if (urlObject.hostname.includes("youtube.com")) {
                    const params = urlObject.pathname.slice(1).split("/");

                    if (params.includes("watch")) {
                        return urlObject.searchParams.get("v");
                    } else if (params.includes("shorts")) {
                        return params.at(-1) ?? null;
                    } else if (params.includes("playlist")) {
                        return urlObject.searchParams.get("list");
                    }
                } else if (urlObject.hostname.includes("youtu.be")) {
                    return urlObject.pathname.slice(1);
                }
                return null;
            }

            private buildYoutubeIframe(
                source: HTMLSourceElement,
                events?: {
                    onReady?: () => void;
                    onUnstarted?: () => void;
                    onEnded?: () => void;
                    onPlaying?: () => void;
                    onPaused?: () => void;
                    onBuffering?: () => void;
                    onCued?: () => void;
                    onSeek?: (currentTime: number, duration: number) => void;
                }
            ): YT.Player {
                let interval: number | null = null;
                const handleStateChange = (state: YT.PlayerState) => {
                    const clrInterval = () => {
                        if (interval !== null) {
                            clearInterval(interval);
                            interval = null;
                        }
                        events?.onSeek?.(player.getCurrentTime(), player.getDuration());
                    };

                    const startInterval = () => {
                        clrInterval();
                        interval = window.setInterval(() => {
                            events?.onSeek?.(player.getCurrentTime(), player.getDuration());
                        }, 100);
                    };

                    switch (state) {
                        case YT.PlayerState.UNSTARTED:
                            events?.onUnstarted?.();
                            break;
                        case YT.PlayerState.ENDED:
                            clrInterval();
                            events?.onEnded?.();
                            break;
                        case YT.PlayerState.PLAYING:
                            startInterval();
                            events?.onPlaying?.();
                            break;
                        case YT.PlayerState.PAUSED:
                            clrInterval();
                            events?.onPaused?.();
                            break;
                        case YT.PlayerState.BUFFERING:
                            clrInterval();
                            events?.onBuffering?.();
                            break;
                        case YT.PlayerState.CUED:
                            events?.onCued?.();
                            break;
                    }
                };
                const player = new YT.Player(source, {
                    videoId: this.getYoutubeId(source.src)!,
                    playerVars: {
                        autohide: 1, // YT.AutoHide.HideAllControls
                        autoplay: 0, // YT.AutoPlay.NoAutoPlay
                        cc_load_policy: 0, // YT.ClosedCaptionsLoadPolicy.UserDefault
                        cc_lang_pref: "es",
                        controls: 0, // YT.Controls.Hide
                        disablekb: 1, // YT.KeyboardControls.Disable
                        enablejsapi: 1, // YT.JsApi.Enable
                        fs: 0, // YT.FullscreenButton.Hide
                        hl: "es",
                        iv_load_policy: 3, // YT.IvLoadPolicy.Hide
                        loop: 0, // YT.Loop.SinglePlay
                        modestbranding: 1, // YT.ModestBranding.Modest
                        mute: 0, // YT.Mute.NotMuted
                        origin: import.meta.env.SITE,
                        playsinline: 1, // YT.PlaysInline.Inline,
                        rel: 0, // YT.RelatedVideos.Hide
                        showinfo: 0 // YT.ShowInfo.Hide
                    },
                    events: {
                        onReady: () => events?.onReady?.(),
                        onStateChange: ({ data }) => handleStateChange(data)
                    }
                });

                return player;
            }

            play() {
                if (this.type === "native") {
                    this.nativePlayer!.play();
                } else if (this.type === "youtube") {
                    if (this.youtubePlayer instanceof HTMLSourceElement) {
                        this.initIframe((e) => e.playVideo());
                    } else {
                        this.youtubePlayer!.playVideo();
                    }
                }
            }

            pause() {
                if (this.type === "native") {
                    this.nativePlayer!.pause();
                } else if (this.type === "youtube") {
                    if (this.youtubePlayer instanceof HTMLSourceElement) {
                        this.initIframe((e) => e.pauseVideo());
                    } else {
                        this.youtubePlayer!.pauseVideo();
                    }
                }
            }

            getState(): string {
                if (this.type === "native") {
                    if (this.nativePlayer!.ended) return "ended";
                    if (this.nativePlayer!.paused && this.getCurrentTime() === 0)
                        return "unstarted";
                    if (this.nativePlayer!.paused) return "paused";
                    if (this.nativePlayer!.readyState < 3) return "buffering";
                    return "playing";
                } else if (this.type === "youtube" && this.youtubePlayer instanceof YT.Player) {
                    switch ((this.youtubePlayer as YT.Player).getPlayerState()) {
                        case YT.PlayerState.ENDED:
                            return "ended";
                        case YT.PlayerState.UNSTARTED:
                        case YT.PlayerState.CUED:
                            return "unstarted";
                        case YT.PlayerState.PAUSED:
                            return "paused";
                        case YT.PlayerState.BUFFERING:
                            return "buffering";
                        case YT.PlayerState.PLAYING:
                            return "playing";
                    }
                }
                return "";
            }

            toggleState() {
                if (this.type === "youtube" && this.youtubePlayer instanceof HTMLSourceElement) {
                    this.initIframe((e) => e.playVideo());
                } else {
                    switch (this.getState()) {
                        case "ended":
                            this.seek(0);
                        case "unstarted":
                        case "paused":
                            this.play();
                            break;
                        case "buffering":
                        case "playing":
                            this.pause();
                            break;
                    }
                }
            }

            getDuration(): number {
                if (this.type === "native") {
                    return this.nativePlayer!.duration;
                } else if (this.type === "youtube" && this.youtubePlayer instanceof YT.Player) {
                    return this.youtubePlayer!.getDuration();
                }
                return -1;
            }

            getCurrentTime(): number {
                if (this.type === "native") {
                    return this.nativePlayer!.currentTime;
                } else if (this.type === "youtube" && this.youtubePlayer instanceof YT.Player) {
                    return this.youtubePlayer!.getCurrentTime();
                }
                return -1;
            }

            getElapsedTime(): string {
                return formatDuration(this.getCurrentTime());
            }

            getRemainingTime(): string {
                return `-${formatDuration(this.getDuration() - this.getCurrentTime())}`;
            }

            seek(seconds: number) {
                if (seconds >= 0 && seconds <= this.getDuration()) {
                    if (this.type === "native") {
                        this.nativePlayer!.currentTime = seconds;
                    } else if (this.type === "youtube" && this.youtubePlayer instanceof YT.Player) {
                        this.youtubePlayer!.seekTo(seconds, true);
                    }
                }
            }

            isMute(): boolean {
                if (this.type === "native") {
                    return this.nativePlayer!.muted;
                } else if (this.type === "youtube" && this.youtubePlayer instanceof YT.Player) {
                    return this.youtubePlayer!.isMuted();
                }
                return true;
            }

            mute() {
                if (this.type === "native") {
                    this.nativePlayer!.muted = true;
                } else if (this.type === "youtube" && this.youtubePlayer instanceof YT.Player) {
                    this.youtubePlayer!.mute();
                }
            }

            unMute() {
                if (this.type === "native") {
                    this.nativePlayer!.muted = false;
                } else if (this.type === "youtube" && this.youtubePlayer instanceof YT.Player) {
                    this.youtubePlayer!.unMute();
                }
            }

            getVolume(): number {
                if (this.type === "native") {
                    return this.nativePlayer!.volume;
                } else if (this.type === "youtube" && this.youtubePlayer instanceof YT.Player) {
                    return this.youtubePlayer!.getVolume();
                }
                return -1;
            }

            volume(val: number) {
                if (this.type === "native") {
                    this.nativePlayer!.volume = val;
                } else if (this.type === "youtube" && this.youtubePlayer instanceof YT.Player) {
                    this.youtubePlayer!.setVolume(val);
                }
            }
        }

        const videos = [...document.body.querySelectorAll<HTMLDivElement>(".video")].map((e) => ({
            container: e,
            controller: new VideoController(e),
            preview: {
                container: e.querySelector<HTMLDivElement>(".preview")!,
                play: e.querySelector<HTMLButtonElement>(".preview > .player-state")!
            },
            controls: {
                container: e.querySelector<HTMLDivElement>(".controls")!,
                play: e.querySelector<HTMLButtonElement>(".controls > .player-state")!,
                slider: e.querySelector<HTMLInputElement>(".controls > .player-time > .slider")!,
                elapsedTime: e.querySelector<HTMLSpanElement>(
                    ".controls > .player-time > .elapsed-time"
                )!,
                remainingTime: e.querySelector<HTMLSpanElement>(
                    ".controls > .player-time > .remaining-time"
                )!,
                screen: e.querySelector<HTMLButtonElement>(".controls > .options > .screen")!
            }
        }));

        const changePlayerState = (video: any, state: string) => {
            video.container.setAttribute("data-state", state);
        };
        const showPreview = (video: any) => {
            video.preview.container.removeAttribute("data-hidden");
        };
        const hidePreview = (video: any) => {
            video.preview.container.setAttribute("data-hidden", "");
        };
        const showControls = (video: any, timeout?: NodeJS.Timeout | null) => {
            video.controls.container.removeAttribute("data-hidden");
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
        };
        const hideControls = (video: any, timeout?: NodeJS.Timeout | null) => {
            video.controls.container.setAttribute("data-hidden", "");
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
        };
        const hideControlsWithTimeout = (video: any, timeout?: NodeJS.Timeout | null) => {
            showControls(video, timeout);
            return setTimeout(() => {
                const state = video.controller.getState();

                if (state === "playing") {
                    hideControls(video);
                }
                if (timeout) {
                    clearTimeout(timeout);
                    timeout = null;
                }
            }, 2500);
        };
        const changeScreenState = (video: any) => {
            if (document.fullscreenElement) {
                video.controls.screen.setAttribute("data-maximized", "");
            } else {
                video.controls.screen.removeAttribute("data-maximized");
            }
        };

        for (const video of videos) {
            let timeout: NodeJS.Timeout | null = null;

            const clickCallbackPlay = () => {
                video.controller.toggleState();
            };
            const inputCallback = () => {
                video.controller.seek(Number(video.controls.slider.value));
                video.controls.elapsedTime.innerText = video.controller.getElapsedTime();
                video.controls.remainingTime.innerText = video.controller.getRemainingTime();
            };
            const mousemoveCallback = () => {
                timeout = hideControlsWithTimeout(video, timeout);
            };
            const clickCallbackScreen = () => {
                if (document.fullscreenElement && document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (video.container.requestFullscreen) {
                    video.container.requestFullscreen();
                }
            };
            const fullscreenchangeCallback = () => {
                changeScreenState(video);
            };

            video.controller.onReady = () => {
                video.controls.slider.max = String(video.controller.getDuration());
                video.controls.slider.dispatchEvent(
                    new CustomEvent("value", {
                        detail: video.controller.getCurrentTime()
                    })
                );
                video.controls.elapsedTime.innerText = video.controller.getElapsedTime();
                video.controls.remainingTime.innerText = video.controller.getRemainingTime();
            };
            video.controller.onEnded = () => {
                // Show preview
                showPreview(video);
                // Hide controls
                video.container.removeEventListener("mousemove", mousemoveCallback);
                hideControls(video, timeout);
                // Change player state
                changePlayerState(video, "ended");
            };
            video.controller.onPlaying = () => {
                // Hide preview
                hidePreview(video);
                // Show controls and hide with timeout
                video.container.removeEventListener("mousemove", mousemoveCallback);
                video.container.addEventListener("mousemove", mousemoveCallback);
                mousemoveCallback();
                // Change player state
                changePlayerState(video, "playing");
            };
            video.controller.onPaused = () => {
                // Show controls
                video.container.removeEventListener("mousemove", mousemoveCallback);
                showControls(video, timeout);
                // Change player state
                changePlayerState(video, "paused");
            };
            video.controller.onBuffering = () => changePlayerState(video, "buffering");
            video.controller.onSeek = (currentTime, duration) => {
                video.controls.slider.max = String(duration);
                video.controls.slider.dispatchEvent(
                    new CustomEvent("value", { detail: currentTime })
                );
                video.controls.elapsedTime.innerText = video.controller.getElapsedTime();
                video.controls.remainingTime.innerText = video.controller.getRemainingTime();
            };

            video.preview.play.addEventListener("click", clickCallbackPlay);
            video.controls.play.addEventListener("click", clickCallbackPlay);
            video.controls.slider.addEventListener("input", inputCallback);
            video.controller.container.addEventListener("click", clickCallbackPlay);
            video.controls.screen.addEventListener("click", clickCallbackScreen);
            document.addEventListener("fullscreenchange", fullscreenchangeCallback);
        }
    </script>
</div>
