---
import type { BaseProps } from "@models/props";

export interface Props extends BaseProps {
    url: string;
    title?: string;
    thumbnail?: string;
}

const getYoutubeId = (url: string) => {
    if (!URL.canParse(url)) return null;

    const urlObject = new URL(url);

    if (urlObject.hostname.includes("youtube.com")) {
        const params = urlObject.pathname.slice(1).split("/");

        if (params.includes("watch")) {
            return urlObject.searchParams.get("v");
        } else if (params.includes("shorts")) {
            return params.at(-1) ?? null;
        } else if (params.includes("playlist")) {
            return urlObject.searchParams.get("list");
        }
    } else if (urlObject.hostname.includes("youtu.be")) {
        return urlObject.pathname.slice(1);
    }
    return null;
};

const { url, id, style, class: cls } = Astro.props;
let { title, thumbnail } = Astro.props;
const youtubeId = getYoutubeId(url);

if (youtubeId && (!title || !thumbnail)) {
    const data = await fetch(
        `https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${youtubeId}&format=json`
    ).then((res) => res.json<any>());

    title = title ?? data["title"];
    thumbnail = thumbnail ?? data["thumbnail_url"];
}
---

<div
    {id}
    {style}
    class:list={cls}
    class="video bg-muted group relative aspect-video h-auto w-auto cursor-default overflow-hidden select-none">
    <div
        class="preview group/alt absolute top-0 left-0 z-20 h-full w-full data-hidden:pointer-events-none">
        <img
            src={thumbnail}
            alt={title}
            loading="lazy"
            decoding="async"
            class="img bg-muted h-full w-full border-none object-cover transition-[scale,opacity] duration-300 outline-none group-data-hidden/alt:scale-110 group-data-hidden/alt:opacity-0"
        />
        <span
            class="text-headline caption absolute top-0 left-0 h-24 w-full bg-linear-to-b from-[#00000099] p-6 text-white transition-[translate,opacity] duration-300 group-data-hidden/alt:-translate-y-100 group-data-hidden/alt:opacity-0">
            {title}
        </span>
        <button
            class="player-state button button-fill-primary absolute top-1/2 left-1/2 h-20 max-h-none w-20 -translate-1/2 rounded-full p-0 transition-[background-color,scale,opacity] group-data-hidden/alt:opacity-0 hover:scale-110">
            <i
                class="ibm-play-filled-alt group-data-[state=buffering]:hidden group-data-[state=ended]:hidden group-data-[state=playing]:hidden">
            </i>
            <i class="ibm-pause-filled group-not-data-[state=playing]:hidden"> </i>
            <i class="ibm-rotate-360 group-not-data-[state=ended]:hidden"></i>
            <span
                class="spinner-alt border-current border-b-transparent group-not-data-[state=buffering]:hidden">
            </span>
        </button>
    </div>
    <div class="player absolute top-0 left-0 h-full w-full bg-black">
        {
            youtubeId ? (
                <source
                    src={url}
                    type="video/youtube"
                    class="pointer-events-none h-full w-full border-none object-cover outline-none"
                />
            ) : (
                <video
                    src={url}
                    playsinline
                    class="pointer-events-none h-full w-full border-none object-cover outline-none"
                />
            )
        }
    </div>
    <div
        class="controls is-hidden clip-none bg-muted data-hidden:clip-top absolute bottom-0 left-0 z-10 flex h-14 w-full flex-row items-center justify-start transition-[clip-path] duration-300">
        <button class="player-state button button-primary relative h-14 w-14 p-0">
            <i
                class="ibm-play-filled-alt group-data-[state=buffering]:hidden group-data-[state=ended]:hidden group-data-[state=playing]:hidden">
            </i>
            <i class="ibm-pause-filled group-not-data-[state=playing]:hidden"> </i>
            <i class="ibm-rotate-360 group-not-data-[state=ended]:hidden"></i>
            <span class="spinner-alt group-not-data-[state=buffering]:hidden"> </span>
        </button>
        <label class="player-time">
            <span class="text-label elapsed-time">00:00</span>
            <input type="range" min="0" max="1" step="0.01" class="slider" />
            <span class="text-label remaining-time">-00:00</span>
        </label>
        <div class="options flex h-14 flex-row items-center justify-start px-2">
            <button
                class="screen group/alt button button-primary group h-10 min-h-0 w-10 min-w-0 p-0">
                <i class="ibm-maximize group-data-maximized/alt:hidden"></i>
                <i class="ibm-minimize group-not-data-maximized/alt:hidden"></i>
            </button>
        </div>
    </div>
</div>

<script>
    import { formatDuration } from "@utils/datetime";

    class VideoController {
        private nativePlayer: HTMLVideoElement | null;
        private youtubePlayer: YT.Player | HTMLSourceElement | null;
        readonly type: string;
        readonly container: HTMLDivElement;
        onReady?: () => void;
        onUnstarted?: () => void;
        onEnded?: () => void;
        onPlaying?: () => void;
        onPaused?: () => void;
        onBuffering?: () => void;
        onCued?: () => void;
        onSeek?: (currentTime: number, duration: number) => void;

        constructor(video: HTMLDivElement) {
            this.container = video.querySelector<HTMLDivElement>(".player")!;
            this.nativePlayer = this.container.querySelector<HTMLVideoElement>("video");
            this.youtubePlayer = this.container.querySelector<HTMLSourceElement>("source");

            // Get player type
            if (this.nativePlayer) {
                this.type = "native";
                // Add listeners
                this.nativePlayer!.addEventListener("canplay", () => {
                    this.onReady?.();
                });
                this.nativePlayer!.addEventListener("playing", () => {
                    this.onPlaying?.();
                });
                this.nativePlayer!.addEventListener("pause", () => {
                    if (!this.nativePlayer!.ended) {
                        this.onPaused?.();
                    }
                });
                this.nativePlayer!.addEventListener("waiting", () => {
                    this.onBuffering?.();
                });
                this.nativePlayer!.addEventListener("ended", () => {
                    this.onEnded?.();
                });
                this.nativePlayer!.addEventListener("timeupdate", () => {
                    this.onSeek?.(this.getCurrentTime(), this.getDuration());
                });
            } else if (this.getYoutubeId(this.youtubePlayer?.src ?? "")) {
                this.type = "youtube";
                // Load youtube iframe api
                if (
                    !document.head.querySelector('script[src="https://www.youtube.com/iframe_api"]')
                ) {
                    const script: HTMLScriptElement = document.createElement("script");

                    script.setAttribute("src", "https://www.youtube.com/iframe_api");
                    document.head.appendChild(script);
                }
            } else {
                throw new Error("No video player found");
            }
        }

        private initIframe(onReady?: (player: YT.Player) => void) {
            if (this.youtubePlayer instanceof HTMLSourceElement) {
                this.youtubePlayer = this.buildYoutubeIframe(this.youtubePlayer!, {
                    onReady: () => {
                        this.onReady?.();
                        onReady?.(this.youtubePlayer as YT.Player);
                    },
                    onUnstarted: this.onUnstarted,
                    onEnded: this.onEnded,
                    onPlaying: this.onPlaying,
                    onPaused: this.onPaused,
                    onBuffering: this.onBuffering,
                    onCued: this.onCued,
                    onSeek: this.onSeek
                });
            }
        }

        private getYoutubeId(url: string) {
            if (!URL.canParse(url)) {
                return null;
            }

            const urlObject = new URL(url);

            if (urlObject.hostname.includes("youtube.com")) {
                const params = urlObject.pathname.slice(1).split("/");

                if (params.includes("watch")) {
                    return urlObject.searchParams.get("v");
                } else if (params.includes("shorts")) {
                    return params.at(-1) ?? null;
                } else if (params.includes("playlist")) {
                    return urlObject.searchParams.get("list");
                }
            } else if (urlObject.hostname.includes("youtu.be")) {
                return urlObject.pathname.slice(1);
            }
            return null;
        }

        private buildYoutubeIframe(
            source: HTMLSourceElement,
            events?: {
                onReady?: () => void;
                onUnstarted?: () => void;
                onEnded?: () => void;
                onPlaying?: () => void;
                onPaused?: () => void;
                onBuffering?: () => void;
                onCued?: () => void;
                onSeek?: (currentTime: number, duration: number) => void;
            }
        ): YT.Player {
            let interval: number | null = null;
            const handleStateChange = (state: YT.PlayerState) => {
                const clrInterval = () => {
                    if (interval !== null) {
                        clearInterval(interval);
                        interval = null;
                    }
                    events?.onSeek?.(player.getCurrentTime(), player.getDuration());
                };

                const startInterval = () => {
                    clrInterval();
                    interval = window.setInterval(() => {
                        events?.onSeek?.(player.getCurrentTime(), player.getDuration());
                    }, 100);
                };

                switch (state) {
                    case YT.PlayerState.UNSTARTED:
                        events?.onUnstarted?.();
                        break;
                    case YT.PlayerState.ENDED:
                        clrInterval();
                        events?.onEnded?.();
                        break;
                    case YT.PlayerState.PLAYING:
                        startInterval();
                        events?.onPlaying?.();
                        break;
                    case YT.PlayerState.PAUSED:
                        clrInterval();
                        events?.onPaused?.();
                        break;
                    case YT.PlayerState.BUFFERING:
                        clrInterval();
                        events?.onBuffering?.();
                        break;
                    case YT.PlayerState.CUED:
                        events?.onCued?.();
                        break;
                }
            };
            const player = new YT.Player(source, {
                videoId: this.getYoutubeId(source.src)!,
                playerVars: {
                    autohide: 1, // YT.AutoHide.HideAllControls
                    autoplay: 0, // YT.AutoPlay.NoAutoPlay
                    cc_load_policy: 0, // YT.ClosedCaptionsLoadPolicy.UserDefault
                    cc_lang_pref: "es",
                    controls: 0, // YT.Controls.Hide
                    disablekb: 1, // YT.KeyboardControls.Disable
                    enablejsapi: 1, // YT.JsApi.Enable
                    fs: 0, // YT.FullscreenButton.Hide
                    hl: "es",
                    iv_load_policy: 3, // YT.IvLoadPolicy.Hide
                    loop: 0, // YT.Loop.SinglePlay
                    modestbranding: 1, // YT.ModestBranding.Modest
                    mute: 0, // YT.Mute.NotMuted
                    origin: import.meta.env.SITE,
                    playsinline: 1, // YT.PlaysInline.Inline,
                    rel: 0, // YT.RelatedVideos.Hide
                    showinfo: 0 // YT.ShowInfo.Hide
                },
                events: {
                    onReady: () => events?.onReady?.(),
                    onStateChange: ({ data }) => handleStateChange(data)
                }
            });

            return player;
        }

        play() {
            if (this.type === "native") {
                this.nativePlayer!.play();
            } else if (this.type === "youtube") {
                if (this.youtubePlayer instanceof HTMLSourceElement) {
                    this.initIframe((e) => e.playVideo());
                } else {
                    this.youtubePlayer!.playVideo();
                }
            }
        }

        pause() {
            if (this.type === "native") {
                this.nativePlayer!.pause();
            } else if (this.type === "youtube") {
                if (this.youtubePlayer instanceof HTMLSourceElement) {
                    this.initIframe((e) => e.pauseVideo());
                } else {
                    this.youtubePlayer!.pauseVideo();
                }
            }
        }

        getState(): string {
            if (this.type === "native") {
                if (this.nativePlayer!.ended) return "ended";
                if (this.nativePlayer!.paused && this.getCurrentTime() === 0) return "unstarted";
                if (this.nativePlayer!.paused) return "paused";
                if (this.nativePlayer!.readyState < 3) return "buffering";
                return "playing";
            } else if (this.type === "youtube" && this.youtubePlayer instanceof YT.Player) {
                switch ((this.youtubePlayer as YT.Player).getPlayerState()) {
                    case YT.PlayerState.ENDED:
                        return "ended";
                    case YT.PlayerState.UNSTARTED:
                    case YT.PlayerState.CUED:
                        return "unstarted";
                    case YT.PlayerState.PAUSED:
                        return "paused";
                    case YT.PlayerState.BUFFERING:
                        return "buffering";
                    case YT.PlayerState.PLAYING:
                        return "playing";
                }
            }
            return "";
        }

        toggleState() {
            if (this.type === "youtube" && this.youtubePlayer instanceof HTMLSourceElement) {
                this.initIframe((e) => e.playVideo());
            } else {
                switch (this.getState()) {
                    case "ended":
                        this.seek(0);
                    case "unstarted":
                    case "paused":
                        this.play();
                        break;
                    case "buffering":
                    case "playing":
                        this.pause();
                        break;
                }
            }
        }

        getDuration(): number {
            if (this.type === "native") {
                return this.nativePlayer!.duration;
            } else if (this.type === "youtube" && this.youtubePlayer instanceof YT.Player) {
                return this.youtubePlayer!.getDuration();
            }
            return -1;
        }

        getCurrentTime(): number {
            if (this.type === "native") {
                return this.nativePlayer!.currentTime;
            } else if (this.type === "youtube" && this.youtubePlayer instanceof YT.Player) {
                return this.youtubePlayer!.getCurrentTime();
            }
            return -1;
        }

        getElapsedTime(): string {
            return formatDuration(this.getCurrentTime());
        }

        getRemainingTime(): string {
            return `-${formatDuration(this.getDuration() - this.getCurrentTime())}`;
        }

        seek(seconds: number) {
            if (seconds >= 0 && seconds <= this.getDuration()) {
                if (this.type === "native") {
                    this.nativePlayer!.currentTime = seconds;
                } else if (this.type === "youtube" && this.youtubePlayer instanceof YT.Player) {
                    this.youtubePlayer!.seekTo(seconds, true);
                }
            }
        }

        isMute(): boolean {
            if (this.type === "native") {
                return this.nativePlayer!.muted;
            } else if (this.type === "youtube" && this.youtubePlayer instanceof YT.Player) {
                return this.youtubePlayer!.isMuted();
            }
            return true;
        }

        mute() {
            if (this.type === "native") {
                this.nativePlayer!.muted = true;
            } else if (this.type === "youtube" && this.youtubePlayer instanceof YT.Player) {
                this.youtubePlayer!.mute();
            }
        }

        unMute() {
            if (this.type === "native") {
                this.nativePlayer!.muted = false;
            } else if (this.type === "youtube" && this.youtubePlayer instanceof YT.Player) {
                this.youtubePlayer!.unMute();
            }
        }

        getVolume(): number {
            if (this.type === "native") {
                return this.nativePlayer!.volume;
            } else if (this.type === "youtube" && this.youtubePlayer instanceof YT.Player) {
                return this.youtubePlayer!.getVolume();
            }
            return -1;
        }

        volume(val: number) {
            if (this.type === "native") {
                this.nativePlayer!.volume = val;
            } else if (this.type === "youtube" && this.youtubePlayer instanceof YT.Player) {
                this.youtubePlayer!.setVolume(val);
            }
        }
    }

    const videos = [...document.body.querySelectorAll<HTMLDivElement>(".video")].map((e) => ({
        container: e,
        controller: new VideoController(e),
        preview: {
            container: e.querySelector<HTMLDivElement>(".preview")!,
            play: e.querySelector<HTMLButtonElement>(".preview > .player-state")!
        },
        controls: {
            container: e.querySelector<HTMLDivElement>(".controls")!,
            play: e.querySelector<HTMLButtonElement>(".controls > .player-state")!,
            slider: e.querySelector<HTMLInputElement>(".controls > .player-time > .slider")!,
            elapsedTime: e.querySelector<HTMLSpanElement>(
                ".controls > .player-time > .elapsed-time"
            )!,
            remainingTime: e.querySelector<HTMLSpanElement>(
                ".controls > .player-time > .remaining-time"
            )!,
            screen: e.querySelector<HTMLButtonElement>(".controls > .options > .screen")!
        }
    }));

    const changePlayerState = (video: any, state: string) => {
        video.container.setAttribute("data-state", state);
    };
    const showPreview = (video: any) => {
        video.preview.container.removeAttribute("data-hidden");
    };
    const hidePreview = (video: any) => {
        video.preview.container.setAttribute("data-hidden", "");
    };
    const showControls = (video: any, timeout?: NodeJS.Timeout | null) => {
        video.controls.container.removeAttribute("data-hidden");
        if (timeout) {
            clearTimeout(timeout);
            timeout = null;
        }
    };
    const hideControls = (video: any, timeout?: NodeJS.Timeout | null) => {
        video.controls.container.setAttribute("data-hidden", "");
        if (timeout) {
            clearTimeout(timeout);
            timeout = null;
        }
    };
    const hideControlsWithTimeout = (video: any, timeout?: NodeJS.Timeout | null) => {
        showControls(video, timeout);
        return setTimeout(() => {
            const state = video.controller.getState();

            if (state === "playing") {
                hideControls(video);
            }
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
        }, 2500);
    };
    const changeScreenState = (video: any) => {
        if (document.fullscreenElement) {
            video.controls.screen.setAttribute("data-maximized", "");
        } else {
            video.controls.screen.removeAttribute("data-maximized");
        }
    };

    for (const video of videos) {
        let timeout: NodeJS.Timeout | null = null;

        const clickCallbackPlay = () => {
            video.controller.toggleState();
        };
        const inputCallback = () => {
            video.controller.seek(Number(video.controls.slider.value));
            video.controls.elapsedTime.innerText = video.controller.getElapsedTime();
            video.controls.remainingTime.innerText = video.controller.getRemainingTime();
        };
        const mousemoveCallback = () => {
            timeout = hideControlsWithTimeout(video, timeout);
        };
        const clickCallbackScreen = () => {
            if (document.fullscreenElement && document.exitFullscreen) {
                document.exitFullscreen();
            } else if (video.container.requestFullscreen) {
                video.container.requestFullscreen();
            }
        };
        const fullscreenchangeCallback = () => {
            changeScreenState(video);
        };

        video.controller.onReady = () => {
            video.controls.slider.max = String(video.controller.getDuration());
            video.controls.slider.dispatchEvent(
                new CustomEvent("value", {
                    detail: video.controller.getCurrentTime()
                })
            );
            video.controls.elapsedTime.innerText = video.controller.getElapsedTime();
            video.controls.remainingTime.innerText = video.controller.getRemainingTime();
        };
        video.controller.onEnded = () => {
            // Show preview
            showPreview(video);
            // Hide controls
            video.container.removeEventListener("mousemove", mousemoveCallback);
            hideControls(video, timeout);
            // Change player state
            changePlayerState(video, "ended");
        };
        video.controller.onPlaying = () => {
            // Hide preview
            hidePreview(video);
            // Show controls and hide with timeout
            video.container.removeEventListener("mousemove", mousemoveCallback);
            video.container.addEventListener("mousemove", mousemoveCallback);
            mousemoveCallback();
            // Change player state
            changePlayerState(video, "playing");
        };
        video.controller.onPaused = () => {
            // Show controls
            video.container.removeEventListener("mousemove", mousemoveCallback);
            showControls(video, timeout);
            // Change player state
            changePlayerState(video, "paused");
        };
        video.controller.onBuffering = () => changePlayerState(video, "buffering");
        video.controller.onSeek = (currentTime, duration) => {
            video.controls.slider.max = String(duration);
            video.controls.slider.dispatchEvent(new CustomEvent("value", { detail: currentTime }));
            video.controls.elapsedTime.innerText = video.controller.getElapsedTime();
            video.controls.remainingTime.innerText = video.controller.getRemainingTime();
        };

        video.preview.play.addEventListener("click", clickCallbackPlay);
        video.controls.play.addEventListener("click", clickCallbackPlay);
        video.controls.slider.addEventListener("input", inputCallback);
        video.controller.container.addEventListener("click", clickCallbackPlay);
        video.controls.screen.addEventListener("click", clickCallbackScreen);
        document.addEventListener("fullscreenchange", fullscreenchangeCallback);
    }
</script>
